是前人对开发经验的总结，用来提高代码复用性、维护性、可读性、稳健性、灵活性、安全性，以及提升开发效率的一系列软件开发方案。这些思想在几乎所有的计算机软硬件设计领域，都是通用的。

设计模式是为软件实体的未来事件制定的对现行开发的约束。

设计模式我认为主要就在做两件事儿：1.尽可能减少未来可能出现的变更导致的扩散；2.让程序的结构更加清晰。

---

下面通过一个例子来向你说明设计模式主要在做些什么、是如何实现这两件事儿的：你学面向对象的编程语言，一定看过很多教材说要把对象封装，要将对象的内部属性设置为私有，然后再用专门的getter、setter访问它。你有没有想过这是为什么？有没有感觉这样做是在白费立即——这不都是在访问他，封装这一层有什么意义？

这就是设计模式中依赖倒置原则的一种体现，假如你将一个类的内部成员设置为public对外开放，然后外部的一堆类都依赖了某些属性，然后某天因为某些因素需要对这个类进行变更，需要对某些属性需要修改，之前的做法就会导致这次的修改发生了扩散，凡是引用到这个属性的地方全要跟着改。但假如你封装进了专门的函数，则只需要更改函数即可。所以虽然有的字段在语义上算不上是一个类的私有、用于内部运行的字段，但依然要用private把它封装起来。

> 当然了这是从设计模式的角度出发。从其他角度还有一些考量，例如权限控制，想让他变成只读或者只写，亦或者是要在读写的时候做点别的事儿。

即：我们应当让模块之间依赖抽象，而不是细节，对于这个例子，抽象就是我要读写某种字段，细节就是这个字段具体是怎样的。我们要让一个模块尽量对外暴露这些几乎永远不会变的抽象，然后把依赖建立在抽象上，而不是细节。这样未来发生了变更，就只需要变更这个模块自己。

---

参考：

- 《设计模式之禅》：非常好的一本书，讲的清晰明了。作者讲任何一件事儿都有生动形象的例子说明，但又能做到例子足够直观简单，能让你一目十行的看下去而不是陷在例子里拖慢节奏。我自己就是跟着这个书学的。时间充裕推荐直接读这本书。

# 六大原则

这些原则我们应当尽量遵守，但不是非满足不可，很多时候也会因为性能、开发成本等因素做出妥协。

## 单一原则（Single Responsibility Principle）

一个接口、类、方法只负责一项职责。

**原始定义：**There should never be more than one reason for a class to change.

**好处：**每个代码片段实现的职责都有明确的定义，所以可读性高、可维护性高；此外，变更风险也得到降低，这是最重要的，一个接口的修改只对相应的实现类有影响，对其他接口无影响。对系统的扩展性、维护性帮助很大。

**要点：**

这一原则的核心是划分职责，只有划分职责之后，才能去拆。但事实上要怎么划分，划分到怎样的粒度，是随情况而定的。实际的项目考虑到诸多的因素诸如开发效率，或者是有些东西未来变化、扩展的可能性，如果你只从“只有一个引起变化的因素”这个角度去看，很多设计并没有做到这一点。

单一职责原则提出了一个编写程序的标准，用“职责”或“变化原因”来衡量接口或类的设计是否优良，但这件事儿本身是不可度量的，究竟什么时候才算”只有一个引起变化的因素“，是因项目而异，因环境而异的。

**最佳实践：**因为前面提到的原因，这一原则的实践时常有着诸多困难。所以一般是接口和方法的设计一定要做到单一职责，类的设计尽量做到只有一个原因引起变化。

## 依赖倒置原则（Dependence Inversion Principle）

**原始定义：**High level modules should not depend upon low level modules. Both should depend upon abstractions. Abstractions should not depend upon details.Details should depend upon abstractions.

> 抽象就是接口或抽象类，细节就是实现类；

- 高层模块不应该依赖底层模块，两者都应该依赖抽象。
- 抽象不应该依赖细节，细节应该依赖抽象。

**更具体一点就是：**面向接口编程。

- 模块之间的依赖通过抽象完成，具体的实现类(能被实例化的类)之间不发生直接的依赖关系，其依赖关系是通过接口或者抽象产生的。
- 接口或抽象不依赖于实现类，反之实现类依赖接口或抽象。

**原因：**

- 稳定性：强依赖的两个模块一旦发生修改，会变得很麻烦，要改动的地方过多。这样的设计不具备稳定性，某些因素一旦变化，整体系统就要大变动。

- 并行开发：思考强依赖情况下，假如有20个人一起完成开发，每个人的模块都强依赖别人的，这就会让开发工作变成“单线程”的，甲做完，乙再做，然后是丙，否则编译器根本不会给你通过，更不用说单元测试什么的。但如果将依赖倒置，对于两个有依赖关系的类，只需要制定出两者之间的接口/抽象类，在接口中根据约定添加mock方法模拟各个类的使用，就可以分别独立开发了，并且独立完成单元测试。

  > 这一点很像前后端分离，事实上前后端分离就正是这一原则的具体应用。

  > Test-Driven Development(TDD，测试驱动开发)开发模式是依赖倒置原则的最高级应用。

**这也是一种约束：**接口的存在，不仅约束相关的类自身，也约束它与外部的关系，保证所有细节不脱离约定发展，相关的类按照既定约定(抽象)共同发展。

**按前文所述，通过抽象的方式实现依赖的三种方法：**

1. 构造函数传递依赖对象

   在构造函数中声明依赖对象。

   按照依赖注入的说法，这是构造函数注入。

2. Setter方法传递依赖对象

   在抽象(例如接口)中设置相应的Setter方法声明依赖关系。

   按照依赖注入的说法，这是Setter依赖注入。

3. 接口声明依赖对象

   在接口的方法中声明依赖对象。

   按照依赖注入的说法，这是接口注入。

**最佳实践：**

-  每个类尽量都有接口或抽象类，或者两者都具备。

- 变量的表面类型尽量都使用接口或者是抽象类。

- 任何类都不应该从具体类派生。

- 尽量不要覆盖基类的方法。

  因为类之间依赖的都是抽象，假如你把一个抽象类已经实现了的方法复写，这会对依赖的稳定性造成一定的影响。

> 现在我们可以再来考虑下，为什么把这种做法称作“依赖倒置”？
>
> 原本强耦合的情况下，直接在一个类中去调用另一个实现类的某些内容，我们将这算为“正置”。比如你在类A中调用类B实例的某个方法，那么此时方法调用要如何书写，是依赖于A、B这两个类的具体情形的，当A或B类发生变动，调用的书写可能也要跟着改变。
>
> 但经过这个原则优化之后，我们对A、B两个类都实现了相应的接口，那原本在那个位置书写的调用，也就变成了对接口的调用。此时的情形就变成了，不管这两个类如何变动，只要接口不变，调用处就无需改变。但相反，只有当接口发生了变化，调用处的写法才发生变化。这就从原先的调用处依赖类的具体实现，变成了类的实现依赖于接口，实现了面向接口编程，即倒置。

## 里氏替换原则（Liskov Substitution Principle）

他旨在解决继承产生的一系列，指导需要使用继承这一特性的代码编写。

子类可以扩展父类的功能，但不能改变原有父类的功能。

**原始定义：**Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it. 所有使用基类的地方必须也能透明的使用其子类对象。

**原因：**因为前面依赖倒置所提到的(参见其最佳实践的第二条)，我们调用其他类时务必要使用父类或者接口，也就是说常常由一个基类派生出多个子类，然后在使用基类类型的变量引用子类类型的实例，这就要求保证向上转型能够正常运作。

**通俗的说：**只要父类出现的地方子类就可以出现，而且替换为子类也不会产生任何错误，使用者根本不需要知道是子类还是父类。

**有关继承： **

继承的好处你肯定学过不少：

- 代码共享提高复用
- 提高扩展性
- 增强语义

哪缺点呢？

- 继承是侵入性的，只要继承就必须拥有父类的所有属性和方法。
- 代码灵活性被降低，子类必须拥有父类的这些东西，让子类的凭空多了很多约束。
- 增强了耦合性，父类里的东西被修改后，还需要考虑子类的修改，在缺乏规范的情况下，这会带来灾难级的大段代码重构。

**要点：**原文中的那句规则，包含了四层含义。

1. 子类必须完全实现父类的方法。

   如果子类不能完整地实现父类的方法，或者父类的某些方法在子类中已经发了生“畸变”，那么为了代码结构更加清晰，则建议断开父子继承关系，采用依赖、聚集、组合等关系代替继承。例如建立一个独立的父类，然后与原父类建立关联委托关系来实现代码复用。

2. 子类中可以增加自己特有的方法。

3. 重载或实现父类的方法时输入参数可以被放大。

   也就是说，如果子类为一个父类已经有了的方法新增了一组参数输入/前置条件，重载的父类的一个方法，那么就要求这组参数从范围上相比于原来父类这个方法的几种参数，只能更大。

   之所以有这样的限制，是因为既然父类的某个方法已经有了设计、或是实现，就说明在设计阶段已经规定了这个方法应有的模式，我们应该遵照这个模式设计子类，否则会使结构变得混乱。

   进一步说，对于父类的某一方法，直接调用父类该方法，传入与所需参数范围相等或者更小的参数都是允许的，都会进入这个方法。那假如子类该方法重载的参数范围更小，在进行向上转型的时候，调用了这个方法，如果传入了一个比父类方法参数范围小的参数(例如父类要求参数的子类)，显然这种情形的调用就会进入子类的对应方法。这与父类设计这一方法时的预期就违背了，父类的这个方法不就白设计了。这会引起结构上的混乱，以及未知的错误。

4. 覆盖或实现父类的方法时输出结果可以被缩小。

   对于非覆盖的情形，道理是显而易见的，因为如果不是覆盖，和原父类方法的函数签名一样的话，那就是”要点3“提到的情形，这种参数情形下被调用的函数一定是父类的，输出结果肯定和父类的是一样的。

   对于覆盖的情形，这是Java等语言对覆盖的要求，天经地义。不过我们可以思考一下为什么这样要求，我认为背后的原理应当和”要点3“提到的是相近的。既然父类已经这样设计过这个方法了，子类就不应该违背这个设计，去返回一些范围更大甚至和原父类方法不相干的结果和异常，造成混乱。并且这也会给类型检查、异常的捕获带来麻烦。

   不过根据定义以及上一段提到的原因，我们尽量不要去覆写父类。

**最佳实践： **里氏替换原则要求尽量避免子类的”个性“，主要是在父类已经指定、完成设计的部分避免”个性“，否则会使得子类和父类之间的关系难以调和。

> 我读《设计模式之禅》一书这部分的最佳实践时，没有读懂：“把子类当做父类使用，子类的“个性”被抹杀——委屈了 点；把子类单独作为一个业务来使用，则会让代码间的耦合关系变得扑朔迷离——缺乏类替 换的标准。”

## 接口隔离原则（Interface Segregation Principle）

这里所指的接口是广义上的接口，即程序内各个组成部分、模块之间起到沟通、连接作用的桥梁。这个接口可以是实例接口，例如Java中的一个类所创造出的实例，调用这个实例中，对应类所开放的属性或方法；这个接口也可以是类接口，即狭义上的接口，指的是编程语言所提供的一种特性，例如Java中interface关键字定义的接口。

**原话：**The dependency of one class to another one should depend on the smallest possible interface.

**通俗的说：**建立单一的接口，不要建立臃肿庞大的接口。接口尽量细化，让接口中的方法尽量少。

**要点：**这听起来似乎和单一职责原则说的是一件事儿？实则不然，接口隔离原则从要求上看比单一职责原则更严格，另一方面，两者关注的侧重点不同。单一职责要求的是类、接口、方法职责单一，只负责一件事儿，这个是从业务的角度来看的。而接口隔离原则是从纯代码的角度，要求接口的方法尽量少，它可能会打碎从单一职责原则出发划出的某个接口。

> 具体一点例如：一个接口可能包含10个方法，他们都是负责的某个不能再分的业务，提供给多个模块访问，在系统的外部通过文档约束外界的模块要访问哪个对应的方法、不使用的方法不要访问。这是符合单一职责原则的。但这不符合接口隔离原则，很多时候，在接口隔离原则看来，这样的接口还要再拆。

**原因：**随着时间的推移，一个过于庞大的接口，会容纳很多可变因素，当有些方法出现了变化，例如修改或者在特定情况下应被移除的时候，不论是实现这个接口的类、还是调用这个接口的类都面临一同修改。因为实现这个接口的类要实现全部的方法，这个接口已经存在的调用处往往也调用了接口的全部方法。

这里说的似乎过于的抽象，《设计模式之禅》一书中“美女星探”的例子非常形象的说明了这一原理，推荐去看看。

**最佳实践：**

- 尽量使用多个专门的接口、而不是建立一个庞大臃肿的接口，容纳所有用户使用。

  - 接口是契约，接口尽量小就意味着接口承诺的事情少，留给未来的余地就大，就灵活。

- 接口要高内聚，尽可能少的对外部依赖。

- 定制服务：对于同一类需求的接口，相比于实现一个面面俱到的复杂接口，不如先实现一个简单的只包含基础内容的接口。然后根据特定的需求，再去额外地实现专门接口。

- **接口的拆分是有限度的，不能无限的考虑未来的变更情况。**

  前面说了接口拆分的好处，但显然接口的过度设计也是有显著副作用的。接口拆的太厉害显而易见的影响就是原本一个单一的业务单元被打的非常散，不易读易懂；其次是接口拆的太厉害，就会多出来一大堆接口，让开发变得十分复杂，这就没完没了了。

  接口粒度太小，接口数剧增；接口粒度太大，灵活性降低，无法妥善应对变化。

  那么如何在两者之间进行折衷呢？在拆分接口时，首先应当满足单一职责原则，即拆分后的接口不能比最小的业务单位还要细很多。除此之外就只能靠经验了。

  > 事实上不光接口隔离原则，这几大原则在实践中都要权衡一些其他因素后找到一个平衡点，取一个折衷的方案，而非一味追求。否则就是物极必反。

- 已经被污染了的接口，尽量去修改，若变更风险较大，则采用适配器模式进行转化处理。

## 迪米特原则（Law of Demeter）

也叫最少知道原则。一个对象应该对其他对象有最少的了解。

> 一个类应该对自己需要耦合或调用的类知道得最少，你（被耦合或者调用得类）内部实现得多复杂和我都没关系，我只需要知道你提供的public方法，我就调用这么多，其他的是你的事情。

**要点：**这简单的一句话可以延申出三层意思。

- 只和朋友交流

  这也是原定义中的一部分：Talk only to your immediate friends and not to strangers.

  什么叫直接朋友呢，每个对象必然会和其他对象有耦合关系，只有出现在成员变量、方法的输入输出参数中的类才是成员的朋友类，而出现在方法内的类不属于。

  也就是说我们要避免在方法内声明其他类/建立耦合，因为这包裹的太深了，很难发现这层依赖，难以从类的层面知道自己的行为和其他的类产生了依赖关系。

  把这种类要想办法移走或者变成朋友类，提高系统的健壮性。

  ---

  上面说的这些东西做的就是一件事儿：不应该让依赖出现在方法内。那么遵照这一点，就还有另一条要求：给方法传参要尽可能具体，而不是范范的传递一个范围很大的对象，然后再在方法内部去获取这个对象的字段。

  > 例如类A调用了类B的某个方法，该方法需要某个对象的某些字段，那这时候就应该直接把对应的字段传入方法，而不是传一整个对象进去，因为对象一旦变动，意味着需要这个对象的位置都要跟着变动，依赖藏得太深难以发现。

  总结：**类之间的关系是建立在类间的，而不是方法间。一个方法尽量不引入一个类中不存在的对象（JDK API提供的类除外）。**

- 朋友之间也是有距离的

  要求类尽量不要对外公布太多的public方法和非静态的public变量，尽量收敛。

  对于多个开放的方法，假如是流程中的若干步，或者类似可被封装的几个方法，应当把这几个方法设置成私有，然后封装成一个方法暴露出去，尽可能地提高类的内聚性。

  因为一个类公开的内容越多，修改时涉及的面也就越大，变更引起的风险就越大。

- 方法该放在哪儿

  实践中经常有这样一种情形，一个方法放在本类中也可以，放在其他类中也没错。这时候对于放在哪儿，遵循这样一个原则：如果一个方法放在本类中，即不增加类间的关系，也对本类不产生负面影响，那就放在本类中。【说白了就是放哪儿耦合低放哪儿。

**最佳实践：**迪米特原则和接口隔离原则都有很明显的一点——过犹不及。迪米特原则的核心思想就是类之间解耦、弱耦合。但这样的结果就是产生大量的中转或跳转类，导致系统复杂度变高，从而也会给维护带来麻烦。所以也要反复权衡，找到一个平衡点。

## 开闭原则（Open Closed Principle）

**原话：**Software entities like classes,modules and functions should be open for extension but closed for modifications. 对扩展开放，但对修改闭合。

对于代码的拓展者，我们应当预留出位置用于扩展；对于代码的使用者，对于不满足其需求的情景，应当让其去扩展，而不是修改代码。

**较为特殊地：**开闭原则从层次上来讲，应该要比其他得原则要高一些，因为其他原则都可以看作开闭原则的一种体现；也正因入如此，开闭原则讲的东西过于泛泛，没有什么具体的操作指南。

**原因：**对于未来发生的变化，有着两种升级程序的思路：一种是修改现有的代码，例如类或者接口；一种是在原有内容的基础上去扩展。开闭原则就是要尽量少做第一件事儿，用第二种思路来实现。

因为接口和类一定存在着大量的耦合。例如因为业务上的新需求，你需要对原先某个类的某个方法进行扩展，你不论是直接变更这个方法、还是变更相应的接口，都意味着有一大堆的已经存在的调用，不能适配变更后的方法。这就意味着这些东西全都要跟着改；除此之外，所有相关的单元测试，肯定也要跟着一起改、然后重新做。

但如果你通过在原有的代码基础上去扩展，为对应方法的类新建一个子类，这个子类重写要变更的这个方法，然后新的业务全都用这个子类的实例去实现，原有业务涉及新业务需要变更的地方也跟着改。需要变更的地方明显就少了很多，并且单元测试也只需要测试你这个新的类，完成了对系统的最小化开发。

**要点：**也就是说，开闭原则要求在未来的升级、维护中，保留历史的纯洁性，放弃修改历史的想法。【然后把屎山越筑越高，但谁让一开始设计就没考虑到这些呢。

**坏处：**通过上面的描述你一定意识到了一个问题，这样不去重构就代码而跑去打补丁的行为，无疑会让系统的结构变得莫名其妙，提高复杂度的同时让系统结构变得很不清晰。

举个例子，把前面那个方法变更得情形变得更具体一些，例如对于商品这种实体，原先有一个方法是获取商品的价格。现在业务有了额外的需求，需要对某些满足特定条件得商品再获取一个折扣价格。

这显然做的都是一个领域得事儿，把他并列在一起，或者写进一个方法里是更符合语义的。但当你按照开闭原则，用一个子类去继承原有这个商品类，然后这个子类叫某种商品折扣类，专门用于获取折扣价，然后代码的调用处里父子两个类混着用，代码一下子就变得很奇怪了。

**最佳实践：**因了前面讲地坏处，这件事儿应该从两种身份出发去看。事实上，我认为开闭原则这种事儿本质上是对团队协作而言，甚至是人员、实践跨度大的情形下的一种编码指导。

对于隔了很长时间，且原来的代码不是这个编写者写的，他只是负责后续版本的开发或者是维护，那么显然开闭原则就是有效的。因为他根本就不熟悉原来那些浩如烟海的代码，你让他搞清楚原来代码错综复杂的细节，把原来代码全都读懂，然后重构所有的依赖、单元测试，这显然是不现实的，搞不好改着改着就改出问题了。所以最好的做法就是不要动，在原有的基础上去扩展。同时原本代码的编写者也要考虑到后续这样的场景，为后来者实施变动留出空间。

但对于初始作者而言，这个代码本来就是你写的，这些问题根本就不存在，你对你写的东西再清楚不过了，那就别打补丁了，直接把你以前写的东西改了，让结构更清晰岂不是更好？

也就是说开闭原则指的是，对**外人**关闭修改，对**外人**开放扩展。这个“外人”指的是，跨越时间、团队，对原先代码细节知之甚少的人。

**总结：**

- 假如现有需要根据业务需求升级的代码本来就是你写的，或者你正在写初版

  - 那你怎么改都没关系，你要想的是怎样让结构更清晰、未来更容易扩展，而不是不动你之前写的代码，跑去打补丁。

  - 尽可能考虑到各种情形，把你的程序设计的更周全；使用抽象层，把抽象层设计好，让它尽可能稳定。

    两种典型的实践：

    - 使用抽象。

    - 利用元数据来描述环境和数据，即使用配置文件/配置参数。

      对于有着不同需求的使用者，通过一个配置文件，来实现这些差异，让其按需进行配置，而不是直接改动代码。一个典型例子就是Spring框架的各种xml配置文件。

  - 同时遵循这个原则，要考虑到以后有别人经手你的代码，尽可能为他的扩展留出余地。让别人只需要在原有的代码上添砖加瓦，就可以实现业务的变化。

- 假如你正在经手的代码不是你写的，你是在此基础上完成你的工作

  - 那就遵循这个原则，原有的代码既然已经投入运行了，就不要修改已有的代码，而是去扩展它。

    【除非是彻底的大返工，但既然是重构，你的身份就已经变成前面描述的那种了。

## 合成复用原则（Composite Reuse Principle）

委派，优先使用对象组合、调用其他对象，而不是通过继承来达到复用的目的。

> 因为继承的耦合度太高。

## 小结

文章开篇就提到了，设计模式是一门应对未来可能发生的变化的学问，这七个原则指导如何应对未来的变化——封装。如何理解封装变化？就是预测到未来的变化、不稳定的点，为这些变化点创建稳定的接口，或者做些其他的事情，将这些变化封装进可控的确定范围内。

下面将要学到的23种设计模式，就是这7大原则的具体应用，从各个不同的角度，对各种变化进行封装。

# 类型

- **创建型模式 CreationalPatterns**

  对类的实例化过程进行抽象，将软件中对象的创建和对象的使用分离。

- **行为型模式 BehavioralPatterns**

  主要涉及算法和对象间的职责分配。通过使用对象组合，行为型模式可以描述一组对象应该如何协作来完成一个整体任务。

- **结构型模式 StructuralPatterns**

  主要涉及如何组合各种对象以便获得更好、更灵活的结构。虽然面向对象的继承机制提供了最基本的子类扩展父类的功能，但结构型模式不仅仅简单地使用继承，而更多地通过组合与运行期的动态组合来实现更灵活的功能。

# UML图

UML是统一建模语言的缩写，为通过面向对象开发的系统提供描述、可视化、文档化、开发指导的一种标准化建模语言，由一组集成图组成。

现在的开发中，设计阶段这东西已经用的很少了，简单了解即可。

分类：

- 静态图
  - 用例图
  - 类图
  - 包图
  - 对象图
  - 部署图
- 动态图
  - 时序图
  - 通信图
  - 状态机图
  - 活动图

## 类图

UML类图中除了类本身的内容，主要是使用六种关系来描述类之间的关系。

### 泛化关系 generalization

使用空心三角箭头表示泛化/继承与实现，描述的是一种对非抽象类的继承，箭头由继承类指向被继承类。例如汽车与SUV。

### 实现关系 realize

用虚线空心三角箭头表示，描述的是一种对抽象类的继承，箭头由实现类指向抽象类。例如车与卡车。

### 聚合关系 aggregation

用菱形空心箭头表示，描述的是整体由部分构成的语义，箭头由部分指向整体。例如学生和班级。需要注意这描述的聚合而不是组合，也就是由同类多个的部分聚合成一类整体，整体不在了但部分依然可以存在。

### 组合关系 composition

用菱形实心箭头表示，描述的是整体由部分组成的语义，箭头由部分指向整体。例如发动机和汽车。他和聚合关系相对，他表示的一种强依赖关系，这里的部分，是完全不同的几个部分，是组成整体的各个零件，整体如果不存在了，则部分也就不存在了。

### 关联关系 association

用直线线型箭头表示，而非三角箭头，描述的是不同类对象之间的结构关系，是一种静态关系，一般由常识或某些专业领域因素决定，描述两个对象之间的一种天然的结构、关联。

例如乘车人和车票。

箭头的指向表示对象之间是否互相知道，默认不强调方向，表示对象之间互相知道。但如果强调方向，A指向B，表示A知道B，但B不知道A。

### 依赖关系 dependency

用虚线线型箭头表示，描述一个对象的运作需要用到另一个对象的关系，箭头由依赖方指向被依赖方。例如订单与订单种的商品。

显然，双向依赖是一种非常糟糕的结构，我们应当尽量总是保证单向依赖，避免双向依赖的产生。

> 六种关系似乎是两两一组能对上的。

## 时序图

展示对象之间交互的图，图中对象按时间顺序排列，展示对象之间消息交互的顺序。

时序图中的元素如下：对象Object、参与者Actor、生命线Lifeline、控制焦点Focus of control/激活/会话、消息Message等。

https://zhuanlan.zhihu.com/p/629630251