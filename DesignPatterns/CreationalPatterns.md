# 简单工厂模式 Simple Factory Pattern

工厂模式是用new方法创建对象的替代，使用工厂模式，专门定义一个类，用于创建其他类的实例，这些类往往都有者共同的父类。这样一来创建这些类时就可以直接调用对应的工厂方法，只需输入正确的参数，就能创建正确的类，将具体创建类的操作交给工厂类来完成。

好处：

- 如果所有对象都用new创建，大量使用此对象时，假如对象的构造方法或者类名等发生了修改，会造成一连串的修改。根据迪米特原则，应当尽量少的和其他对象交互、知道他们的细节。所以如果使用工厂模式，有一天出现了修改，则只需要修改工厂方法，不需要大规模修改。
- 除此之外，利用工厂方法创建，则可以在创建的过程中定义一系列的判断、以及伴随创建的动作。【不过这个其实new一个对象也可以实现，只需要在对应构造器定义判断以及伴随对象实例化要做的事即可。但显然利用工厂方法能做的事情更多，比如下面“工厂方法模式-增强-产品对象的重复使用”这部分就是一个很好的例子。

不足：

- 简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。（Java中类的静态方法无法被继承）

- 如果只是按照上面那种模式，思考这样一种情景。一个类有很多子类，现在在这个类中通过工厂方法，根据参数创建对应类型的子类。但问题是假如调用者需要创造的子类，目前还不存在怎么办？那他是不是就需要去添加子类、修改工厂方法。但这就违反了开闭原则，我们应当对修改关闭。那么我们就要对拓展开放，该如何开放增强扩展性呢？使用泛型。↓

# 工厂方法模式 Factory Method Pattern

这是对上面模式的优化。同样的，某一类各种类型对象不通过new来创建。但也不再设计一个工厂类同一负责创建：先创建一个抽象的总的工厂类，再定义具体某一种类对象对应的工厂类，这个类继承并实现那个总的抽象工厂类中的方法。创建某个类的时候，通过这个类对应的工厂类中的工厂方法来创建。

好处：出现新的类之后，只需要增加对应的工厂类。这样抽象化话的结果使得，可以在不修改原有工厂类的情况下由代码的使用者按需引入新的类，并且依旧按照这种模式来创建实例，更加符合开闭原则。

增强：

- 可以给这个抽象工厂内定义多个工厂方法，由具体的工厂类去实现这些不同的工厂方法，进一步拓展。
- 产品对象的重复使用：可以将创建的对象保存到一个集合里，集中管理，在用户利用工厂创建时，根据用户对产品的请求，在集合里按照一定的规则判断是否已经存在一个这样的对象，存在就可以直接返回，否则创建一个新的加入集合并返回给客户端。

# 抽象工厂模式 Abstract Factory

